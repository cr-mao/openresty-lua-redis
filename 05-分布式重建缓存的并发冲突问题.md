## 分布式重建缓存的并发冲突问题

lua代码里会先去worker内存中取数据，再到redis里面取数据，如果redis取不到，就会去源站获取，如果还是取不到，就需要重建缓存了。
但是重建缓存有一个问题，因为我们的服务可能是多实例的，虽然在nginx层我们通过流量分发将请求通过id分发到了不同的nginx应用层上。
那么到了接口服务层，可能多次请求访问的是不同的实例，那么可能会导致多个机器去重建读取相同的数据，然后写入缓存中，这就有了分布式重建缓存的并发问题



**冲突问题**

    问题:可能2个实例获取到的数据快照不一样，但是新数据先写入缓存，如果这个时候另外一个实例的缓存后写入，就有问题了。
    
    
    
**解决方案（使用分布式锁)**

变更缓存重建更新redis之前，都需要先获取对应id的分布式锁
拿到分布式锁之后，需要根据时间版本去比较一下，如果自己的版本新于redis中的版本，那么就更新，否则就不更新
如果拿不到分布式锁，那么就等待，不断轮询等待，直到自己获取到分布式的锁


**分布式锁的基本条件**

首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下几个条件：
- 1、互斥性。在任意时刻，只有一个客户端能持有锁。
- 2、不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。（设置过期时间)
- 3、解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了，即不能误解锁。


代码见 ./php/index.php 





